name: 一杯茶的时间，上手 Docker
id: 442cc8dad3310b0aec2ea119ebc884a2
github: 'https://github.com/tuture-dev/docker-dream'
description: >-
  努力工作，然后进入梦乡，“工作”和“做梦”之间好像没有任何关联；编写代码，然后部署应用，这两者似乎也是天各一边。然而果真如此吗？这篇文章将通过《盗梦空间》的方式打开
  Docker，让你实现从“做梦”到“筑梦”的实质性转变。在原先的“做梦”阶段（手动配置和部署），一切都充满了随机性和不可控性，你有时甚至都无法回忆起具体做的每一步；而在“筑梦”阶段（借助
  Docker），你将通过自动化、高度可重复且可追踪的方式轻松实现任何配置和部署任务。希望读完这篇文章的你，也能成为一个优秀的“筑梦师”！
topics:
  - Docker
categories:
  - 工具
  - Docker
  - 入门
created: '2020-01-01T07:17:34.647Z'
updated: 2020-01-12T12:31:14.108Z
splits:
  - name: 一杯茶的时间，上手 Docker
    id: 442cc8dad3310b0aec2ea119ebc884a2
    start: '5573938'
    end: 06a33bd
    cover: tuture-assets/cover-1.jpg
    topics:
      - Docker
    description: >-
      努力工作，然后进入梦乡，“工作”和“做梦”之间好像没有任何关联；编写代码，然后部署应用，这两者似乎也是天各一边。然而果真如此吗？这篇文章将通过《盗梦空间》的方式打开
      Docker，让你实现从“做梦”到“筑梦”的实质性转变。在原先的“做梦”阶段（手动配置和部署），一切都充满了随机性和不可控性，你有时甚至都无法回忆起具体做的每一步；而在“筑梦”阶段（借助
      Docker），你将通过自动化、高度可重复且可追踪的方式轻松实现任何配置和部署任务。希望读完这篇文章的你，也能成为一个优秀的“筑梦师”！
  - name: Docker 包教包会（一）：用 Network 实现容器互联
    id: cd44c8468a5c475985364cae57387491
    start: '60786e9'
    end: '60786e9'
    cover: tuture-assets/cover-2.jpg
    description: >-
      在实际应用中，不同的服务之间是需要通信的，例如后端 API 和数据库；幸运的是，Docker
      为我们提供了网络（Network）机制，能够轻松实现容器互联。这篇文章将带你轻松上手 Docker
      网络，学会使用默认网络和自定义网络，成为一名能够连接多个“梦境”的筑梦师！
steps:
  - name: 准备工作
    commit: '5573938'
    diff:
      - file: client/.gitignore
      - file: client/README.md
      - file: client/package-lock.json
      - file: client/package.json
      - file: client/public/index.html
      - file: client/src/components/App.js
      - file: client/src/components/Footer.js
      - file: client/src/components/Header.js
      - file: client/src/components/Link.js
      - file: client/src/components/MainSection.js
      - file: client/src/components/TodoItem.js
      - file: client/src/components/TodoList.js
      - file: client/src/components/TodoTextInput.js
      - file: client/src/index.js
      - file: client/src/stores/todo.js
      - file: client/src/utils/index.js
      - file: server/.gitignore
      - file: server/index.js
      - file: server/models/Todo.js
      - file: server/package-lock.json
      - file: server/package.json
      - file: server/routes/todos.js
    explain:
      pre: "### 写在前面的话\n\n很多朋友跟我们反馈说，“一杯茶”纯粹就是忽悠人，写那么长，怎么可能在一杯茶的时间内看完？实际上，“饮茶”的方式因人而异，不同的读者自有不同的节奏。你完全可以选择一目十行、甚至只浏览一下插图，几分钟的时间便能看完；也可以选择跟着我们一步一步动手实践，甚至在有些地方停下来思考一番，虽然需要花更多的时间，但是我们相信这份投入的时间一定是值得的。\n\n其次，我们想确认你是否是这篇文章的受众：\n\n1. 如果你已经是每天操纵数以千计容器的 DevOps 大佬，那么很抱歉打扰了，这篇文章对你来说可能过于简单；\n2. 如果你已经比较熟悉 Docker 了，想要更多的实战操作经验，这篇文章能够较好地帮助你复习和巩固关键的知识点；\n3. 如果你只听说过 Docker，但是基本上不会用，那么这篇文章就是为你准备的！只不过友情提醒：**Docker 上手略有难度，想要真正掌握需要投入足够的时间，认真读完这篇文章一定能让你有相当大的进步**。\n\n最后，每个小节的结构都是**实战演练 + 回忆与升华**。回忆与升华部分是笔者花了不少时间对优质资源进行搜集和整合而成，并结合了自身使用容器的经验，相信能够进一步加深你的理解，如果你赶时间的话，也可以略过哦。\n\nPS：这篇文章并没有像常规的 Docker 教程一样上来就郑重其事地讲 Docker 的背景、概念、优势（很有可能你已经听到耳朵生茧了hhh），而是完全通过实践的方式直观地理解 Docker。在最后，我们还是会贴出经典的 Docker 架构图，结合之前的操作体验，相信你会有了然于胸的感觉。\n\n### 前提条件\n\n在正式阅读这篇文章之前，我们希望你已经具备以下条件：\n\n- 最基本的命令行操作经验\n- 对计算机网络有一定的了解，特别是应用层中的**端口**这一概念\n- 最好经历过配环境、部署项目的痛苦挣扎\U0001F62D\n\n### 我们将实现什么\n\n现在假定你手头已经有了一个 React 编写的“梦想清单”项目，如下面这个动图所示：\n\n![](tuture-assets/dream-demo.gif)\n\n我们将在这篇文章中教你一步步用 Docker 将这个应用容器化，用 Nginx 服务器提供构建好的静态页面。\n\n### 你将学会\n\n![](tuture-assets/mindnode-1.jpg)\n\n### 这篇文章不会涉及 ...\n\n当然咯，这篇文章作为一篇入门性质的教程，以下进阶内容不会涉及：\n\n- Docker 网络机制\n- 数据卷和 Bind Mount 实现数据分享\n- Docker Compose\n- 多阶段构建（Multi-stage Build）\n- Docker Machine 工具\n- 容器编排技术，例如 Kubernetes 以及 Docker Swarm\n\n以上进阶知识我们会马上推出相关教程，敬请期待。\n\n### 安装 Docker\n\n我们推荐各个平台用以下方式安装 Docker（经过我们反复测试哦）。\n\n#### Windows\n\n[菜鸟教程](https://www.runoob.com/docker/windows-docker-install.html)中详细介绍了 Win7/8 以及 Win10 的不同推荐安装方法。注意 Win10 建议开启 Hyper-V 虚拟化技术。\n\n#### macOS\n\n可通过点击[官方下载链接](https://download.docker.com/mac/stable/Docker.dmg)下载并安装 DMG 文件（如果速度慢的话可以把链接复制进迅雷哦）。安装完毕之后，点击 Docker 应用图标即可打开。\n\n#### Linux\n\n对于各大 Linux 发行版（Ubuntu、CentOS 等等），我们推荐用官方脚本进行安装，方便快捷：\n\n```bash\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh\n```\n\n然后推荐将 `docker` 的权限移交给非 root 用户，这样使用 `docker` 就不需要每次都 `sudo` 了：\n\n```bash\nsudo usermod -aG docker $USER\n```\n\n注销用户或者重启之后就会生效。然后通过 `systemd` 服务配置 Docker 开机启动：\n\n```bash\nsudo systemctl enable docker\n```\n\n#### 配置镜像仓库\n\n默认的镜像仓库 Docker Hub 在国外，国内拉取速度比较感人。建议参考[这篇文章](https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html)配置镜像加速。"
      post: "## 镜像与容器：筑梦师的图纸和梦境\n\n**镜像**（Image）和**容器**（Container）是 Docker 中最为基础也是最为关键的两个概念，前者就是**筑梦师的图纸**，根据这张图纸的内容，就能够生成**完全可预测的梦境**（也就是后者）。\n\n::: info\n**提示**\n\n如果你觉得这个比喻难以理解，那么可以通过面向对象编程中“类”（class）和“实例”（instance）这两个概念进行类比，“类”就相当于“镜像”，“实例”就相当于“容器”。\n:::\n\n### 小试牛刀：梦开始的地方\n\n在略微接触了镜像与容器这两个基础概念之后，我们打算暂停理论的讲解，而先来一波小实验让你快速感受一下。\n\n#### 实验一：Hello World!\n\n按照历史惯例，我们运行一下来自 Docker 的 Hello World，命令如下：\n\n```bash\ndocker run hello-world\n```\n\n输出如下：\n\n```text\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete\nDigest: sha256:fb158b7ad66f4d58aa66c4455858230cd2eab4cdf29b13e5c3628a6bfc2e9f05\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\n...\n```\n\n不就打印了一个字符串然后退出吗，有这么神奇？其实 Docker 为我们默默做了以下事情：\n\n1. 检查本地是否有指定的 `hello-world:latest` 镜像（`latest` 是镜像标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步\n2. 本地没有指定镜像（Unable to find xxx locally），从 [Docker Hub](https://hub.docker.com/) 下载到本地\n3. 根据本地的 `hello-world:latest` 镜像创建一个新的容器并运行其中的程序\n4. 运行完毕后，容器退出，控制权返回给用户\n\n#### 实验二：运行一个 Nginx 服务器\n\n感觉太简单？我们来尝试一个高级一点的：运行一个 [Nginx 服务器](https://baike.baidu.com/item/nginx)。运行以下命令\n\n```bash\ndocker run -p 8080:80 nginx\n```\n\n运行之后，你会发现一直卡住，也没有任何输出，但放心你的电脑并没有死机。让我们打开浏览器访问 `localhost:8080`：\n\n![](tuture-assets/docker-nginx.png)\n\n这时候熟悉 Nginx 的朋友可能就坐不住了：就一个简简单单的 `docker run` 命令，就搞定了 Nginx 服务器的安装和部署？？没错，你可以继续访问一些不存在的路由，比如 `localhost:8080/what`，同样会提示 404。这时候我们再看 Docker 容器的输出，就有内容（服务器日志）了：\n\n![](tuture-assets/docker-nginx-log.png)\n\n总结一下刚才 Docker 做的事情：\n\n1. 检查本地是否有指定的 `nginx:latest` 镜像（关于 `latest` 标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步\n2. 本地没有指定镜像（Unable to find xxx locally），从 [Docker Hub](https://hub.docker.com/) 下载到本地\n3. 根据本地的 `nginx:latest` 镜像创建一个新的容器，**并通过 `-p`（`--publish`）参数建立本机的 8080 端口与容器的 80 端口之间的映射**，然后运行其中的程序\n4. Nginx 服务器程序保持运行，容器也不会退出\n\n::: info\n**提示**\n\n端口映射规则的格式为 `<本机端口>:<容器端口>`。Nginx 容器默认开放了 80 端口，我们通过设置 `8080:80` 的端口映射规则，就可以在本机（容器之外）通过访问 `localhost:8080` 访问，甚至可以在同一局域网内通过内网 IP 访问，这篇文章的最后会演示哦。\n:::\n\n#### 实验三：后台运行 Nginx\n\n看上去很酷，不过像 Nginx 服务器这样的进程我们更希望把它抛到后台一直运行。按 Ctrl + C 退出当前的容器，然后再次运行以下命令：\n\n```bash\ndocker run -p 8080:80 --name my-nginx -d nginx\n```\n\n注意到与之前不同的是，我们：\n\n- 加了一个参数 `--name`，用于指定容器名称为 `my-nginx`\n- 加了一个选项 `-d`（`--detach`），表示“后台运行”\n\n::: warning\n**警告**\n\n容器的名称必须是唯一的，如果已经存在同一名称的容器（即使已经不再运行）就会创建失败。如果遇到这种情况，可以删除之前不需要的容器（后面会讲解怎么删除）。\n:::\n\nDocker 会输出一串长长的 64 位容器 ID，然后把终端的控制权返回给了我们。我们试着访问 `localhost:8080`，还能看到那一串熟悉的 Welcome to nginx!，说明服务器真的在后台运行起来了。\n\n那我们怎么管理这个服务器呢？就像熟悉的 UNIX `ps` 命令一样，`docker ps` 命令可以让我们查看当前容器的状态：\n\n```bash\ndocker ps\n```\n\n输出结果是这样的：\n\n![](tuture-assets/docker-ps.png)\n\n::: info\n**提示**\n\n由于 `docker ps` 的输出比较宽，如果你觉得结果不直观的话可以把终端（命令行）拉长，如下图所示：\n\n![](tuture-assets/docker-ps-long.png)\n:::\n\n从这张表中，就可以清晰地看到了我们在后台运行的 Nginx 服务器容器的一些信息：\n\n- 容器 ID（Container ID）为 `0bddac16b8d8`（你机器上的可能不一样）\n- 所用镜像（Image）为 `nginx`\n- 运行命令/程序（Command）为 `nginx -g 'daemon of...`，这个是 Nginx 镜像自带的运行命令，暂时不用关心\n- 创建时间（Created）为 45 seconds ago（45 秒钟之前）\n- 当前状态（Status）为 Up 44 seconds（已运行 44 秒钟）\n- 端口（Ports）为 `0.0.0.0:8080->80/tcp`，意思是访问本机的 `0.0.0.0:8080` 的所有请求会被转发到该容器的 TCP 80 端口\n- 名称（Names）为刚才指定的 `my-nginx`\n\n如果我们要让容器停下来，通过 `docker stop` 命令指定容器名称或 ID 进行操作即可，命令如下：\n\n```bash\ndocker stop my-nginx\n# docker stop 0bddac16b8d8\n```\n\n::: warning\n**注意**\n\n如果指定容器 ID 的话，记得要换成自己机器上真实的 ID 哦。此外，在没有冲突的情况下，ID 可以只写前几位字符，例如写 `0bd` 也是可以的。\n:::\n\n#### 实验四：交互式运行\n\n在过了一把 Nginx 服务器的瘾之后，我们再来体验一下 Docker 容器的另一种打开方式：**交互式运行**。运行以下命令，让我们进入到一个 Ubuntu 镜像中：\n\n```bash\ndocker run -it --name dreamland ubuntu\n```\n\n可以看到我们加了 `-it` 选项，等于是同时指定 `-i`（`--interactive`，交互式模式）和 `-t`（`--tty`，分配一个模拟终端） 两个选项。以上命令的输出如下：\n\n```text\nUnable to find image 'ubuntu:latest' locally\nlatest: Pulling from library/ubuntu\n2746a4a261c9: Pull complete\n4c1d20cdee96: Pull complete\n0d3160e1d0de: Pull complete\nc8e37668deea: Pull complete\nDigest: sha256:9207fc49baba2e62841d610598cb2d3107ada610acd4f47252faf73ed4026480\nStatus: Downloaded newer image for ubuntu:latest\nroot@94279dbf5d93:/#\n```\n\n等下，我们怎么被抛在了一个新的命令行里面？没错，你现在已经在这个 Ubuntu 镜像构筑的“梦境”之中，你可以随意地“游走”，运行一些命令：\n\n```bash\nroot@94279dbf5d93:/# whoami\nroot\nroot@94279dbf5d93:/# ls\nbin   dev  home  lib64  mnt  proc  run   srv  tmp  var\nboot  etc  lib   media  opt  root  sbin  sys  usr\n```\n\n例如我们在上面运行了 `whoami` 和 `ls` 命令，你基本上可以确定现在已经在“梦境”（容器）之中了。这时候打开一个新的终端（命令行），运行 `docker ps` 命令\b，就可以看到正在运行中的 Ubuntu 镜像：\n\n![](tuture-assets/docker-ps-ubuntu.png)\n\n回到之前的容器中，按 Ctrl + D （或者输入 `exit` 命令）即可退出。你可以在之前查看 `docker ps` 的终端再次检查容器是否已经被关闭了。\n\n### 销毁容器：听梦碎的声音\n\n筑梦师难免会有失败的作品，而我们刚才创建的 Docker 容器也只是用于初步探索，后续不会再用到。由于 Docker 容器是直接存储在我们本地硬盘上的，及时清理容器也能够让我们的硬盘压力小一些。我们可以通过以下命令查看所有容器（包括已经停止的）：\n\n```bash\ndocker ps -a\n```\n\n`-a`（`--all`）用于显示所有容器，如果不加的话只会显示**运行中**的容器。可以看到输出如下（这里我把终端拉宽了，方便你看）：\n\n![](tuture-assets/docker-ps-a.png)\n\n::: info\n**提示**\n\n你也许观察到，之前的实验一和实验二中我们没有指定容器名称，Docker 为我们取了颇为有趣的默认容器名称（比如 `hardcore_nash`），格式是一个随机的形容词加上一位著名科学家/程序员的姓氏（运气好的话，你可能会看到 Linux 之父 `torvalds` 哦）。\n:::\n\n类似 Shell 中的 `rm` 命令，我们可以通过 `docker rm` 命令销毁容器，例如删除我们之前创建的 `dreamland` 容器：\n\n```bash\ndocker rm dreamland\n# 或者指定容器 ID，记得替换成自己机器上的\n# docker rm 94279dbf5d93\n```\n\n但如果我们想要销毁所有容器怎么办？一次次输入 `docker rm` 删除显然不方便，可以通过以下命令轻松删除**所有容器**：\n\n```bash\ndocker rm $(docker ps -aq)\n```\n\n`docker ps -aq` 会输出所有容器的 ID，然后作为参数传给 `docker rm` 命令，就可以根据 ID 删除所有容器啦。\n\n::: danger\n**危险！**\n\n执行之前一定要仔细检查是否还有**有价值**的容器（特别是业务数据），因为容器一旦删除无法再找回（这里不讨论硬盘恢复这种黑科技）！\n:::\n\n### 回忆与升华\n\n#### 关于端口映射\n\n可能有些同学还是没有完全理解“端口映射”的概念，以 `8080:80` 这一条映射规则为例，我们可以用“传送门”的比喻来理解（下面的图是《传送门2》游戏的封面）：\n\n![](tuture-assets/portal.png)\n\n还是把容器比作“梦境”，把本机环境比作“现实”，通过建立端口映射，访问本机的 `8080` 端口的请求就会被“传送”到容器的 `80` 端口，是不是很神奇呢。\n\n#### 容器生命周期：梦境地图\n\n跟着做完上面四个小实验之后，你或许已经对 Docker 容器有了非常直观的感受和理解了。是时候祭出这张十（sang）分（xin）经（bing）典（kuang）的 Docker 容器生命周期图了（来源：https://docker-saigon.github.io/post/Docker-Internals/）：\n\n![](tuture-assets/lifecycle.png)\n\n这张图乍一看颇具视觉冲击力，甚至会让你感觉不知所措。没事，我们大致地解读这张图里面的四类元素：\n\n1. **容器状态**（带颜色的圆圈）：包括已创建（Created）、运行中（Running）、已暂停（Paused）、已停止（Stopped）以及被删除（Deleted）\n2. **Docker 命令**（箭头上以 `docker` 开头的文字）：包括 `docker run`、`docker create`、`docker stop` 等等\n3. **事件**（矩形框）：包括 `create`、`start`、`die`、`stop` 还有 `OOM`（内存耗尽）等等\n4. 还有一个条件判断，根据重启策略（Restart Policy）判断是否需要重新启动容器\n\nOK，这张图还是很难一下子理解，不过还记得刚才我们做的四个小实验吗？我们实际上走了一共两条路径（也是日常使用中走的最多的路），接下来将一一进行分析。\n\n#### 第一条路径（自然结束）\n\n![](tuture-assets/lifecycle-path1.png)\n\n如上图所示：\n\n- 我们先通过 `docker run` 命令，直接创建（create）并启动（start）一个容器，进入到**运行状态**（Running）\n- 然后程序运行结束（例如输出 Hello World 之后，或者通过 Ctrl + C 使得程序终止），容器死亡（die）\n- 由于我们没有设置重启策略，所以直接进入到**停止状态**（Stopped）\n- 最后通过 `docker rm` 命令销毁容器，进入到**被删除状态**（Deleted）\n\n#### 第二条路径（强制结束）\n\n![](tuture-assets/lifecycle-path2.png)\n\n- 我们还是通过 `docker run` 命令，直接创建（create）并启动（start）一个容器，进入到**运行状态**（Running）\n- 然后通过 `docker stop` 命令杀死容器中的程序（die）并停止（stop）容器，最终进入到**停止状态**（Stopped）\n- 最后通过 `docker rm` 命令销毁容器，进入到**被删除状态**（Deleted）\n\n::: info\n**提示**\n\n有些眼尖的读者可能发现 `docker kill` 和 `docker stop` 的功能非常相似，它们之前存在细微的区别： `kill` 命令向容器内运行的程序直接发出 SIGKILL 信号（或其他指定信号），而 `stop` 则是先发出 SIGTERM 再发出 SIGKILL 信号，属于**优雅关闭**（Graceful Shutdown）。\n:::\n\n#### 一条捷径：删除运行中的容器\n\n生命周期图其实有一条捷径没有画出来：直接从**运行中**（或**暂停中**）到**被删除**，通过给 `docker rm` 命令加上选项 `-f`（`--force`，强制执行）就可以实现：\n\n```bash\n# 假设 dreamland 还在运行中\ndocker rm -f dreamland\n```\n\n同样地，我们可以删除所有容器，无论处于什么状态：\n\n```bash\ndocker rm -f $(docker ps -aq)\n```\n\n#### 自由探索\n\n你尽可以自由探索其他我们没走过的路线，例如尝试再次启动之前已经停止的容器（`docker start`），或者暂停正在运行的容器（`docker pause`）。幸运的是，`docker help` 命令可以为我们提供探索的指南针，例如我们想了解 `start` 命令的使用方法：\n\n```bash\n$ docker help start\n\nUsage:\tdocker start [OPTIONS] CONTAINER [CONTAINER...]\n\nStart one or more stopped containers\n\nOptions:\n  -a, --attach                  Attach STDOUT/STDERR and forward signals\n      --checkpoint string       Restore from this checkpoint\n      --checkpoint-dir string   Use a custom checkpoint storage directory\n      --detach-keys string      Override the key sequence for\n                                detaching a container\n  -i, --interactive             Attach container's STDIN\n```\n\n读到这里，相信你已经了解了如何利用现有的镜像创造容器，并进行管理。在接下来，我们将带你创建自己的 Docker 镜像，开始成为一名标准的“筑梦师”！"
  - name: 容器化第一个应用：开启筑梦之旅
    commit: 06a33bd
    diff:
      - file: client/config/nginx.conf
        display: true
        explain:
          pre: >-
            ### 构建镜像


            构建 Docker 镜像主要包括两种方式：


            1. **手动**：根据现有的镜像创建并运行一个容器，进入其中进行修改，然后运行 `docker commit`
            命令根据修改后的容器创建新的镜像

            2. **自动**：创建 Dockerfile 文件，指定构建镜像的命令，然后通过 `docker build` 命令直接创建镜像


            由于篇幅有限，这篇文章只会讲解**使用最为广泛**的第二种创建镜像的方式。


            #### 一些准备工作


            我们先把前端项目 `client` 构建成一个静态页面。确保你的机器上已经安装 Node 和
            npm（点击[这里](https://nodejs.org/zh-cn/)下载，或使用
            [`nvm`](https://github.com/nvm-sh/nvm)），然后进入到 `client`
            目录下，安装所有依赖，并构建项目：


            ```bash

            cd client

            npm install

            npm run build

            ```


            等待一阵子后，你应该可以看到 `client/build` 目录，存放了我们要展示的前端静态页面。


            创建 Nginx 配置文件 `client/config/nginx.conf`，代码如下：
          post: >-
            不熟悉 Nginx 配置的同学不用担心哦，直接复制粘贴就可以了。上面的配置大致意思是：监听 80 端口，网页根目录在
            `/www`，首页文件是 `index.html`，如果访问 `/` 则提供文件 `index.html`。
      - file: client/Dockerfile
        display: true
        explain:
          pre: |-
            #### 创建 Dockerfile

            然后就是这一步骤中最重要的代码：Dockerfile！创建 `client/Dockerfile` 文件，代码如下：
          post: >-
            可以看到我们用了 Dockerfile 中的三个指令：


            - `FROM` 用于指定基础镜像，这里我们基于 `nginx:1.13` 镜像作为构建的起点

            - `RUN` 命令用于在容器内运行任何命令（当然前提是命令必须存在）

            - `COPY` 命令用于从 Dockerfile 所在的目录拷贝文件到容器指定的路径


            是时候来构建我们的镜像了，运行以下命令：


            ```bash

            # 如果你已经在 client 目录中

            #（注意最后面有个点，代表当前目录）

            docker build -t dream-client .


            # 如果你回到了项目根目录

            docker build -t dream-client client

            ```


            可以看到我们指定了 `-t`（`--tag`，容器标签）为 `dream-client`，最后指定了构建容器的上下文目录（也就是
            当前目录 `.` 或 `client`）。


            运行以上的命令之后，你会发现：


            ```text

            Sending build context to Docker daemon：66.6MB

            ```


            而且这个数字还在不断变大，就像黑客科幻电影中的场景一样，最后应该停在了 290MB 左右。接着运行了一系列的 Step（4
            个），然后提示镜像构建成功。


            为啥这个构建上下文（Build Context）这么大？因为我们把比“黑洞”还“重”的 node_modules
            也加进去了！（忍不住想起了下面这张图）


            ![](tuture-assets/node_modules.jpg)
      - file: client/.dockerignore
        display: true
        explain:
          pre: >-
            #### 使用 .dockerignore 忽略不需要的文件


            Docker 提供了类似 .gitignore 的机制，让我们可以在构建镜像时忽略特定的文件或目录。创建
            `client/.dockerignore` 文件（注意 dockerignore 前面有一个点）：
          post: |-
            很简单，我们只想忽略掉可怕的 node_modules。再次运行构建命令：

            ```bash
            docker build -t dream-client .
            ```

            ![](tuture-assets/docker-build-nginx.png)

            太好了！这次只有 1.386MB，而且速度也明显快了很多！
    explain:
      pre: >-
        在之前的步骤中，我们体验了别人为我们提前准备好的镜像（例如 `hello-world`、`nginx` 和 `ubuntu`），这些镜像都可以在
        [Docker Hub](https://hub.docker.com/)
        镜像仓库中找到。在这一步，我们将开始筑梦之旅：学习如何**容器化**（Containerization）你的应用。


        正如开头所说，我们将容器化一个全栈的”梦想清单“应用，运行以下命令来获取代码，然后进入项目：


        ```bash

        git clone -b start-point https://github.com/tuture-dev/docker-dream.git

        cd docker-dream

        ```


        在这一步中，我们将容器化这个用 React 编写的前端应用，用 Nginx 来提供前端页面的访问。


        ### 什么是容器化


        容器化包括三个阶段：


        - **编写代码**：我们已经提供了写好的代码

        - **构建镜像**：也就是这一节的核心内容，下面会详细展开

        - **创建和运行容器**：通过容器的方式运行我们的应用
      post: >-
        ### 运行容器


        终于到了容器化的最后一步——创建并运行我们的容器！通过以下命令运行刚才创建的 `dream-client` 镜像：


        ```bash

        docker run -p 8080:80 --name client -d dream-client

        ```


        与之前类似，我们还是设定端口映射规则为 `8080:80`，容器名称为 `client`，并且通过 `-d` 设置为后台运行。然后访问
        `localhost:8080`：


        ![](tuture-assets/finish-demo1.gif)


        成功了！一开始定下的三个梦想也都完成了！


        ::: info

        **提示**


        甚至，我们已经可以通过内网来访问“梦想清单”了。Linux 或 macOS 的同学可以在终端输入 `ifconfig` 命令查询本机内网
        IP，Windows 的同学则是在 CMD 输入 `ipconfig` 查询本机内网 IP，一般是以
        `10`、`172.16`~`172.31` 或 `192.168` 开头。例如我的内网 IP 是
        `192.168.0.2`，那么在同一局域网下（一般是 WiFi），可以用其他设备（比如说你的手机）访问 `192.168.0.2:8080`。

        :::


        ### 回忆与升华


        #### 关于镜像标签


        在刚才的实战中，你也许已经注意到在拉取和构建镜像时，Docker 总是会为我们加上一个 `:latest` 标签，这个 `:latest`
        的含义便是“最新”的意思。和软件的版本机制一样，镜像也可以通过标签实现“版本化”。



        ::: warning

        **注意**


        `latest`
        字面上的意思的确是“最新的”，但也只是一个普通的标签，并不能确保真的是“最新的”，更**不会自动更新**。更多讨论请参考[这篇文章](http://dockone.io/article/165)。

        :::


        实际上，我们完全可以在拉取或构建镜像时指定标签（通常被认为是一种好的做法）：


        ```bash

        docker pull nginx:1.13

        docker build -t dream-client:1.0.0

        ```


        还可以给现有的镜像打上标签：


        ```bash

        # 把默认的 latest 镜像打上一个 newest 标签

        docker tag dream-client dream-client:newest

        # 甚至可以同时修改镜像的名称和标签

        docker tag dream-client:1.0.0 dream-client2:latest

        ```


        可以看到，标签未必一定是版本，还可以是任何字符串（当然最好要有意义，否则过了一阵子你也不记得这个打了这个标签的容器有什么作用了）。


        #### 关于 Dockerfile


        Dockerfile 实际上是默认名称，我们当然可以取一个别的名字，例如 `myDockerfile`，然后在构建镜像时指定
        `-f`（`--file`）参数即可：


        ```bash

        docker build -f myDockerfile -t dream-client .

        ```


        这里举两个经典的使用场景：


        1. 例如在 Web 开发时，分别创建 `Dockerfile.dev` 用于构建开发镜像，创建 `Dockerfile.prod`
        构建生产环境下的镜像；

        2. 在训练 AI 模型时，创建 `Dockerfile.cpu` 用于构建用 CPU 训练的镜像，创建 `Dockerfile.gpu`
        构建用 GPU 训练的镜像。


        #### 再次思考镜像和容器的关系


        经过刚才的容器化实战，相信你对镜像和容器的关系又有了新的理解。请看下面这张图：


        ![](tuture-assets/image-container.png)


        在之前的“小试牛刀”环节中（用绿色箭头标出），我们：


        1. 通过 `docker pull` 从 Docker 镜像仓库拉取镜像到本地

        2. 通过 `docker run` 命令，根据镜像创建并运行容器

        3. 通过 `docker stop` 等命令操作容器，使其发生各种状态转变


        而在这一节的容器化实战中（用红色箭头标出），我们：


        1. 通过 `docker build` 命令，根据一个 Dockerfile 文件构建镜像

        2. 通过 `docker tag` 命令，给镜像打上标签，得到一个新镜像

        3. （由于篇幅有限没有讲）通过 `docker commit` 命令，将一个现有的容器转化为镜像


        #### 俯瞰全景：Docker 架构图


        是时候拿出经典的 Docker 架构图了：


        ![](tuture-assets/engine-components-flow.png)


        可以看到，Docker 遵循经典的客户端-服务器架构（client-server），核心组成部分包括：


        - 服务器（也就是 Docker 守护进程），在 Linux 系统中也就是 `dockerd` 命令

        - 服务器暴露出的 REST API，提供了与守护进程通信和操作的接口

        - 客户端（也就是我们一直在用的命令行程序 `docker`）


        至此，这篇 Docker 快速入门实战教程也就结束啦，希望你已经对 Docker 的概念和使用有了初步的理解。后续我们还会发表 Docker
        进阶的内容（例如 Network 网络、Volume 数据卷、Docker Compose
        等等），手把手带大家部署一个全栈应用（前后端和数据库）到云主机（或任何你能够登录的机器），敬请期待~
  - name: '连接容器: 梦境亦相通'
    commit: '60786e9'
    diff:
      - file: server/Dockerfile
        display: true
        explain:
          pre: |-
            ### 动手实践

            #### 容器化服务器

            我们首先对后端服务器也进行容器化。创建 `server/Dockerfile`，代码如下：
          post: >-
            可以看到这个 Dockerfile
            比[上一篇教程](https://tuture.co/2020/01/01/442cc8d/)中的要复杂不少。每一行的含义已经注释在代码中了，我们来看一看多了哪些新东西：


            - `RUN` 指令用于在容器中运行任何命令，这里我们通过 `npm install` 安装所有项目依赖（当然之前配置了一下 npm
            镜像，可以安装得快一点）

            - `ENV` 指令用于向容器中注入环境变量，这里我们设置了 数据库的连接字符串 `MONGO_URI`（**注意这里给数据库取名为
            `dream-db`，后面就会创建这个容器**），还配置了服务器的 `HOST` 和 `PORT`

            - `EXPOSE` 指令用于开放端口 4000。之前在用 Nginx 容器化前端项目时没有指定，是因为 Nginx 基础镜像已经开放了
            8080 端口，无需我们设置；而这里用的 Node 基础镜像则没有开放，需要我们自己去配置

            - `CMD` 指令用于指定此容器的启动命令（也就是 `docker ps` 查看时的 COMMAND
            一列），对于服务器来说当然就是保持运行状态。在后面“回忆与升华”部分会详细展开。


            ::: warning

            **注意**


            初次尝试容器的朋友很容易犯的一个错误就是忘记将服务器的 `host` 从 `localhost`（`127.0.0.1`）改成
            `0.0.0.0`，导致服务器无法在容器之外被访问到（*我自己学习的时候也浪费了很多时间*）。

            :::
      - file: server/.dockerignore
        display: true
        explain:
          pre: >-
            与之前前端容器化类似，创建 `server/.dockerignore` 文件，忽略服务器日志 `access.log` 和
            `node_modules`，代码如下：
          post: >-
            在项目根目录下运行以下命令，构建服务器镜像，指定名称为 `dream-server`：


            ```bash

            docker build -t dream-server server

            ```


            #### 连接服务器与数据库


            根据之前的知识，我们为现在的“梦想清单”应用创建一个自定义网络 `dream-net`：


            ```bash

            docker network create dream-net

            ```


            我们使用官方的 `mongo` 镜像创建并运行 MongoDB 容器，命令如下：


            ```bash

            docker run --name dream-db --network dream-net -d mongo

            ```


            我们指定容器名称为 `dream-db`（还记得这个名字吗），所连接的网络为 `dream-net`，并且在后台模式下运行（`-d`）。



            ::: info

            **提示**


            你也许会问，为什么这里开启容器的时候没有指定端口映射呢？因为**在同一自定义网络中的所有容器会互相暴露所有端口**，不同的应用之间可以更轻松地相互通信；同时，除非通过
            `-p`（`--publish`）手动开放端口，**网络之外无法访问网络中容器的其他端口**，实现了良好的隔离性。**网络之内的互操作性**和**网络内外的隔离性**也是
            Docker Network 的一大优势所在。

            :::



            ::: danger

            **危险！**


            这里我们在开启 MongoDB
            数据库容器时没有设置任何鉴权措施（例如设置用户名和密码），所有连接数据库的请求都可以任意修改数据，在生产环境是极其危险的。后续文章中我们会讲解如何在容器中管理机密信息（例如密码）。

            :::



            然后运行服务器容器：


            ```bash

            docker run -p 4000:4000 --name dream-api --network dream-net -d
            dream-server

            ```


            查看服务器容器的日志输出，确定 MongoDB 连接成功：


            ```bash

            $ docker logs
            dream-api                                                       

            Server is running on http://0.0.0.0:4000

            Mongoose connected.

            ```


            接着你可以通过 Postman 或者 curl 来测试一波服务器 API  （`localhost:4000`
            ），这里为了节约篇幅就省略了。当然你也可以直接跳过，因为马上我们就可以通过前端来操作数据了！


            #### 容器化前端页面


            正如[上一篇文章](https://tuture.co/2020/01/01/442cc8d/)所实现的那样，在项目根目录下，通过以下命令进行容器化：


            ```bash

            docker build -t dream-client client

            ```


            然后运行容器：


            ```bash

            docker run -p 8080:80 --name client -d dream-client

            ```


            可以通过 `docker ps` 命令检验三个容器是否全部正确开启：


            ![](tuture-assets/docker-ps-fullstack.png)


            最后，访问 `localhost:8080`：


            ![](tuture-assets/docker-network-demo.gif)


            可以看到，我们在最后刷新了几次页面，数据记录也都还在，说明我们带有数据库的全栈应用跑起来了！让我们通过交互式执行的方式进入到数据库容器
            `dream-db` 中，通过 Mongo Shell 简单地查询一波刚才的数据：


            ```bash

            $ docker exec -it dream-db mongo

            MongoDB shell version v3.4.10

            connecting to: mongodb://127.0.0.1:27017

            MongoDB server version: 3.4.10

            Welcome to the MongoDB shell.

            For interactive help, type "help".

            > use todos

            switched to db todos

            > db.getCollection('todos').find()

            { "_id" : ObjectId("5e171fda820251a751aae6f5"), "completed" : true,
            "text" : "了解 Docker Network", "timestamp" :
            ISODate("2020-01-09T12:43:06.865Z"), "__v" : 0 }

            { "_id" : ObjectId("5e171fe08202517c11aae6f6"), "completed" : true,
            "text" : "搭建默认网络", "timestamp" :
            ISODate("2020-01-09T12:43:12.205Z"), "__v" : 0 }

            { "_id" : ObjectId("5e171fe3820251d1a4aae6f7"), "completed" : false,
            "text" : "搭建自定义网络", "timestamp" :
            ISODate("2020-01-09T12:43:15.962Z"), "__v" : 0 }

            ```


            完美！然后按 Ctrl + D 就可以退出来了。
    explain:
      pre: >-
        在[上一篇教程](https://tuture.co/2020/01/01/442cc8d/)中，我们带你了解了镜像和容器这两大关键的概念，熟悉了常用的
        docker 命令，并成功地容器化了第一个应用。但是，那只是我们“筑梦之旅”的序章。接下来，我们将实现后端 API 服务器 + 数据库的容器化。


        我们为你准备好了应用程序代码，请运行以下命令：


        ```bash

        # 如果你看了上一篇教程，仓库已经克隆下来了

        cd docker-dream

        git fetch origin network-start

        git checkout network-start


        # 如果你打算直接从这篇教程开始

        git clone -b network-start
        https://github.com/tuture-dev/docker-dream.git

        cd docker-dream

        ```


        和之前容器化前端静态页面服务器相比，多了一个难点：服务器和数据库分别是两个独立的容器，但是服务器需要连接和访问数据库，怎么实现跨容器之间的通信？


        在《盗梦空间》中，不同的梦境之间是无法连接的，然而幸运的是在 Docker 中是可以的——借助 Docker Network。


        ::: info

        **提示**


        在早期，Docker 容器可以通过 docker run 命令的 `--link` 选项来连接容器，但是 Docker
        官方宣布这种方式已经过时，并有可能被移除

        （[参考文档](https://docs.docker.com/network/links/)）。而本文将讲解 Docker
        官方推荐的方式连接容器：**自定义网络**（User-defined Networks）。

        :::


        ### Network 类型


        Network，顾名思义就是“网络”，能够让不同的容器之间相互通信。首先有必要要列举一下 Docker Network
        的五种驱动模式（driver）：


        - `bridge`：默认的驱动模式，即“网桥”，通常用于**单机**（更准确地说，是单个 Docker 守护进程）

        - `overlay`：Overlay 网络能够连接多个 Docker 守护进程，通常用于**集群**，后续讲 Docker Swarm
        的文章会重点讲解

        - `host`：直接使用主机（也就是运行 Docker 的机器）网络，仅适用于 Docker 17.06+ 的集群服务

        - `macvlan`：Macvlan 网络通过为每个容器分配一个 MAC
        地址，使其能够被显示为一台物理设备，适用于希望直连到物理网络的应用程序（例如嵌入式系统、物联网等等）

        - `none`：禁用此容器的所有网络


        **这篇文章将围绕默认的 Bridge 网络驱动展开**。没错，就是连接不同梦境的那座“桥”。


        ### 小试牛刀


        我们还是通过一些小实验来理解和感受 Bridge Network。与上一节不同的是，我们将使用 [Alpine
        Linux](https://www.alpinelinux.org/) 镜像作为实验原材料，因为：


        - 非常轻量小巧（整个镜像仅 5MB 左右）

        - 功能丰富，比“瑞士军刀” [Busybox](https://www.busybox.net/) 还要完善


        网桥网络可分为两类：


        1. 默认网络（Docker 运行时自带，不推荐用于生产环境）

        2. 自定义网络（推荐使用）


        让我们分别实践一下吧。


        #### 默认网络


        这个小实验的内容如下图所示：


        ![](tuture-assets/network-1.png)


        我们会在默认的 `bridge` 网络上连接两个容器 `alpine1` 和 `alpine2`。 运行以下命令，查看当前已有的网络：


        ```bash

        docker network ls

        ```


        应该会看到以下输出（注意你机器上的 ID 很有可能不一样）：


        ```bash

        NETWORK ID          NAME                DRIVER              SCOPE

        cb33efa4d163        bridge              bridge              local

        010deedec029        host                host                local

        772a7a450223        none                null                local

        ```


        这三个默认网络分别对应上面的 `bridge`、`host` 和 `none` 网络类型。接下来我们将创建两个容器，分别名为 `alpine1`
        和 `alpine2`，命令如下：


        ```bash

        docker run -dit --name alpine1 alpine

        docker run -dit --name alpine2 alpine

        ```


        `-dit` 是 `-d`（后台模式）、`-i`（交互模式）和
        `-t`（虚拟终端）三个选项的合并。通过这个组合，我们可以让容器保持在后台运行而不会退出（没错，相当于是在“空转”）。


        用 `docker ps` 命令确定以上两个容器均在后台运行：


        ```bash

        CONTAINER ID        IMAGE               COMMAND            
        CREATED             STATUS              PORTS               NAMES

        501559d2fab7        alpine              "/bin/sh"           2 seconds
        ago       Up 1 second                             alpine2

        18bed3178732        alpine              "/bin/sh"           3 seconds
        ago       Up 2 seconds                            alpine1

        ```


        通过以下命令查看默认的 `bridge` 网络的详情：


        ```bash

        docker network inspect bridge

        ```


        应该会输出 JSON 格式的网络详细数据：


        ```json

        [
          {
            "Name": "bridge",
            "Id": "cb33efa4d163adaa61d6b80c9425979650d27a0974e6d6b5cd89fd743d64a44c",
            "Created": "2020-01-08T07:29:11.102566065Z",
            "Scope": "local",
            "Driver": "bridge",
            "EnableIPv6": false,
            "IPAM": {
              "Driver": "default",
              "Options": null,
              "Config": [
                {
                  "Subnet": "172.17.0.0/16",
                  "Gateway": "172.17.0.1"
                }
              ]
            },
            "Internal": false,
            "Attachable": false,
            "Ingress": false,
            "ConfigFrom": {
              "Network": ""
            },
            "ConfigOnly": false,
            "Containers": {
              "18bed3178732b5c7a37d7ad820c111fac72a6b0f47844401d60a18690bd37ee5": {
                "Name": "alpine1",
                "EndpointID": "9c7d8ee9cbd017c6bbdfc023397b23a4ce112e4957a0cfa445fd7f19105cc5a6",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
              },
              "501559d2fab736812c0cf181ed6a0b2ee43ce8116df9efbb747c8443bc665b03": {
                "Name": "alpine2",
                "EndpointID": "da192d61e4b2df039023446830bf477cc5a9a026d32938cb4a350a82fea5b163",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
              }
            },
            "Options": {
              "com.docker.network.bridge.default_bridge": "true",
              "com.docker.network.bridge.enable_icc": "true",
              "com.docker.network.bridge.enable_ip_masquerade": "true",
              "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
              "com.docker.network.bridge.name": "docker0",
              "com.docker.network.driver.mtu": "1500"
            },
            "Labels": {}
          }
        ]

        ```


        我们重点要关注的是两个字段：


        - `IPAM`：IP 地址管理信息（IP Address Management），可以看到网关地址为
        `172.17.0.1`（由于篇幅有限，想要了解**网关**的同学可自行查阅计算机网络以及 TCP/IP 协议方面的资料）

        - `Containers`：包括此网络上连接的所有容器，可以看到我们刚刚创建的 `alpine1` 和 `alpine2`，它们的 IP
        地址分别为 `172.17.0.2` 和 `172.17.0.3`（后面的 `/16` 是子网掩码，暂时不用考虑）


        ::: info

        **提示**


        如果你熟悉 Go 模板语法，可以通过 `-f`（`format`）参数过滤掉不需要的信息。例如我们只想查看 `bridge` 的网关地址：


        ```bash

        $ docker network inspect --format '{{json .IPAM.Config }}' bridge

        [{"Subnet":"172.17.0.0/16","Gateway":"172.17.0.1"}]

        ```

        :::


        让我们进入 `alpine1` 容器中：


        ```bash

        docker attach alpine1

        ```


        ::: warning

        **注意**


        `attach` 命令只能进入设置了交互式运行的容器（也就是在启动时加了 `-i` 参数）。

        :::



        如果你看到前面的命令提示符变成 `/ #`，说明我们已经身处容器之中了。我们通过 `ping` 命令测试一下网络连接情况，首先 ping
        一波图雀社区的主站 tuture.co（`-c` 参数代表发送数据包的数量，这里我们设为 5）：


        ```

        / # ping -c 5 tuture.co

        PING tuture.co (150.109.19.98): 56 data bytes

        64 bytes from 150.109.19.98: seq=2 ttl=37 time=65.294 ms

        64 bytes from 150.109.19.98: seq=3 ttl=37 time=65.425 ms

        64 bytes from 150.109.19.98: seq=4 ttl=37 time=65.332 ms


        --- tuture.co ping statistics ---

        5 packets transmitted, 3 packets received, 40% packet loss

        round-trip min/avg/max = 65.294/65.350/65.425 ms

        ```


        OK，虽然丢了几个包，但是可以连上（取决于你的网络环境，全丢包也是正常的）。由此可见，**容器内可以访问主机所连接的全部网络**（包括
        localhost）。


        接下来测试能否连接到 `alpine2`，在刚才 `docker network inspect` 命令的输出中找到 `alpine2` 的
        IP 为 `172.17.0.3`，尝试能否 ping 通：


        ```

        / # ping -c 5 172.17.0.3

        PING 172.17.0.3 (172.17.0.3): 56 data bytes

        64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.147 ms

        64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.103 ms

        64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.102 ms

        64 bytes from 172.17.0.3: seq=3 ttl=64 time=0.125 ms

        64 bytes from 172.17.0.3: seq=4 ttl=64 time=0.125 ms


        --- 172.17.0.3 ping statistics ---

        5 packets transmitted, 5 packets received, 0% packet loss

        round-trip min/avg/max = 0.102/0.120/0.147 ms

        ```


        完美！我们能够从 `alpine1` 中访问 `alpine2` 容器。作为练习，你可以自己尝试一下能否从 `alpine2` 容器中 ping
        通 `alpine1` 哦。


        ::: warning

        **注意**


        如果你不想让 `alpine1` 停下来，记得通过 Ctrl + P + Ctrl + Q（按住 Ctrl，然后依次按 P 和 Q
        键）“脱离”（detach，也就是刚才 `attach` 命令的反义词）容器，而不是按 Ctrl + D 哦。

        :::


        #### 自定义网络


        如果你跟着上面一路试下来，会发现默认的 bridge 网络存在一个很大的问题：**只能通过 IP
        地址相互访问**。这毫无疑问是非常麻烦的，当容器数量很多的时候难以管理，而且每次的 IP 都可能发生变化。


        而自定义网络则很好地解决了这一问题。**在同一个自定义网络中，每个容器能够通过彼此的名称相互通信**，因为 Docker 为我们搞定了 DNS
        解析工作，这种机制被称为**服务发现**（Service Discovery）。具体而言，我们将创建一个自定义网络 `my-net`，并创建
        `alpine3` 和 `alpine4` 两个容器，连上 `my-net`，如下图所示。


        ![](tuture-assets/network-2.png)


        让我们开始动手吧。首先创建自定义网络 `my-net`：


        ```bash

        docker network create my-net

        # 由于默认网络驱动为 bridge，因此相当于以下命令

        # docker network create --driver bridge my-net

        ```


        查看当前所有的网络：


        ```bash

        docker network ls

        ```


        可以看到刚刚创建的 `my-net`：


        ```

        NETWORK ID          NAME                DRIVER              SCOPE

        cb33efa4d163        bridge              bridge              local

        010deedec029        host                host                local

        feb13b480be6        my-net              bridge              local

        772a7a450223        none                null                local

        ```


        创建两个新的容器 `alpine3` 和 `alpine4`：


        ```bash

        docker run -dit --name alpine3 --network my-net alpine

        docker run -dit --name alpine4 --network my-net alpine

        ```


        可以看到，我们通过 `--network` 参数指定容器想要连接的网络（也就是刚才创建的 `my-net`）。


        ::: info

        **提示**


        如果在一开始创建并运行容器时忘记指定网络，那么下次再想指定网络时，可以通过 `docker network connect`
        命令再次连上（第一个参数是网络名称 `my-net`，第二个是需要连接的容器 `alpine3`）：


        ```bash

        docker network connect my-net alpine3

        ```

        :::


        进入到 `alpine3` 中，测试能否 ping 通 `alpine4`：


        ```

        $ docker attach alpine3

        / # ping -c 5 alpine4

        PING alpine4 (172.19.0.3): 56 data bytes

        64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.247 ms

        64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.176 ms

        64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.180 ms

        64 bytes from 172.19.0.3: seq=3 ttl=64 time=0.176 ms

        64 bytes from 172.19.0.3: seq=4 ttl=64 time=0.161 ms


        --- alpine4 ping statistics ---

        5 packets transmitted, 5 packets received, 0% packet loss

        round-trip min/avg/max = 0.161/0.188/0.247 ms

        ```


        可以看到 `alpine4` 被自动解析成了 `172.19.0.3`。我们可以通过 `docker network inspect`
        来验证一下：


        ```bash

        $ docker network inspect --format '{{range .Containers}}{{.Name}}:
        {{.IPv4Address}} {{end}}' my-net

        alpine4: 172.19.0.3/16 alpine3: 172.19.0.2/16

        ```


        可以看到 `alpine4` 的 IP 的确为 `172.19.0.3`，解析是正确的！


        #### 一些收尾工作


        实验做完了，让我们把之前所有的容器全部销毁：


        ```bash

        docker rm -f alpine1 alpine2 alpine3 alpine4

        ```


        把创建的 `my-net` 也删除：


        ```bash

        docker network rm my-net

        ```
      post: >-
        ### 回忆与升华


        #### 理解命令：梦境的主旋律


        每个容器自从被创建之时，就注定要运行一道命令（Command），就好像在筑梦时要安排一个主旋律、一个基调那样。之前在运行 `docker ps`
        的时候，你应该也注意到了 `COMMAND` 一栏，正是每个容器所运行的命令。那么我们怎么指定容器的命令呢？又能不能运行新的命令呢？


        首先，我们主要通过两种方式指定容器的命令：


        ##### 通过 Dockerfile 提供默认命令


        在构建镜像时，我们可以在 `Dockerfile` 的最后通过 `CMD` 指令指定命令，例如在构建后端服务器时的 `[ "node",
        "server.js" ]` 命令。在指定命令时，我们有三种写法：


        - `CMD ["executable","param1","param2"]`（exec 格式，**推荐**）

        - `CMD ["param1","param2"]`（需要结合 Entrypoint 使用）

        - `CMD command param1 param2`（shell 格式）


        其中 `executable` 代表可执行文件的路径，例如 `node`、`/bin/sh`；`param1`、`param2`
        代表参数。*我们在后续讨论 Dockerfile 的高阶使用时会讨论 Entrypoint 的使用，这篇文章不会涉及*。


        ::: warning

        **注意**


        在使用第一种 exec 格式时，必须使用**双引号**，因为整个命令将以 JSON 格式被解析。

        :::


        ::: info

        **提示**


        如果要执行变量替换等 Shell 操作，例如 `echo $HOME`，直接写成 `["echo", "$HOME"]` 是无效的，需要改写成
        `["sh", "-c", "echo $HOME"]`。

        :::


        ##### 创建或运行容器时指定命令


        在创建或运行容器时，通过添加命令参数可以**覆盖**构建镜像时指定的命令，例如：


        ```bash

        docker run nginx echo hello

        ```


        通过指定 `echo hello` 命令参数，就会让这个容器输出一个 hello 然后退出，而不会运行默认的 `nginx -g 'daemon
        off;'`。


        当然，正如[第一篇文章](https://tuture.co/2020/01/01/442cc8d/)所实践的，我们还可以指定命令为
        `bash`（或 `sh`、`mongo`、`node` 等其他交互式程序），然后结合 `-it` 选项，就可以进入容器中交互式运行了。


        ##### 通过 exec 运行新的命令


        通过 `docker exec`，我们可以让已经运行中的容器执行新的命令。例如，对于我们之前的 `dream-db` 容器，我们通过
        `mongodump` 命令来创建数据库备份：


        ```bash

        docker exec dream-db mongodump

        ```


        然后可以进一步通过 `docker exec -it` 来进入 `dream-db` 中进行交互式运行，检查刚才导出的 `dump` 目录：


        ```text

        $ docker exec -it dream-db bash

        root@c51d9355d8da:/# ls dump/

        admin  todos

        ```


        同样地，按 Ctrl + D 退出就可以了。


        ::: info

        **提示**


        你也许会好奇，为什么在 `docker run` 交互式执行的时候按 Ctrl + D 就容器就直接停止了，而在 `docker exec`
        的情况下退出却不会导致容器停止呢？因为 `docker exec -it`
        相当于在现有的容器上运行了一个新的终端进程，而不会影响之前的主命令进程。只要主进程不结束，容器就不会停止。

        :::


        #### 小诀窍：如何轻松记住几十个 Docker 命令？


        在刚才的实战中，我们也接触了很多新的 Docker 命令，怎么记住那么多命令呢？其实 docker 大部分命令都符合以下格式：


        ```

        docker <对象类型> <操作名称> [其他选项和参数]

        ```


        - **对象类型**：到目前，我们接触的 Docker 对象类型包括**容器** 
         `container`、**镜像** `image` 和**网络** `network`
        - **操作名称**：操作可以分为两大类：1）适用于所有对象的操作，例如 `ls`、`rm`、`inspect` 和 `prune`
        等等；2）对象专属操作，例如容器专有的 `run` 操作，镜像专有的 `build` 操作，以及网络专有的 `connect` 操作等等

        - **其他选项和参数**：可通过 `help` 命令或 `--help` 查阅每个命令具体的选项和参数


        由于部分命令很常用，Docker 还提供了方便的简写命令，例如显示当前所有容器 `docker container ls`，可以简写成
        `docker ps`。


        我们首先复习一下容器（Container）对象上的命令吧（红色代表适用于所有对象的操作，蓝色代表此对象的专有操作）：


        ![](tuture-assets/container-commands-squashed.jpg)


        再复习一下镜像（Image）对象上的命令：


        ![](tuture-assets/image-commands-squashed.jpg)


        最后复习一下网络（Network）对象上的命令：


        ![](tuture-assets/network-commands-squashed.jpg)


        至此，这篇教程也结束了。但是我们的筑梦之旅才刚刚开始——还有很多问题没有解决：1）现在前端应用还无法在除了本地以外的环境使用（因为访问的后端
        API 是硬编码的 `localhost`）；2）还没有真正部署到远程机器；3）MongoDB
        还处于“裸奔”的状态（没设置密码）。不要方，我们在接下里的教程中就会去解决哦。
